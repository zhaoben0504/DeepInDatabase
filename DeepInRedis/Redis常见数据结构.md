# 一、Redis

redis是一种基于内存的数据库，对数据读写操作都是在内存中进行的，所以读写速度非常快

## 为何使用redis作为Mysql的缓存

1. redis具备高性能

   假如用户第一次访问Mysql中的某些数据，这个过程会比较慢，因为是从硬盘中读取的，将改用户访问的数据缓存到Redis中，这样下次访问就可以从Redis缓存中直接拿

2. redis具备高并发

   单台设备的Redis的QPS是Mysql的10倍，redis单机的QPS能够轻松过10万，而Mysql的单机QPS很难过1万

## 二、Redis常用的数据结构

![img](.\image\d470dea36edf06e9ddc7689a722a9156.png)

### 常见应用场景

- String

  缓存对象、常规计数、分布式锁、共享Session

- List

  消息队列（但有两个问题1.生产者需要自行实现全局唯一ID；2.不能以消费组形式消费数据）

- Hash

  缓存对象、购物车

- Set

  聚合计算（交集并集差集），比如点赞、共同关注、抽奖活动等

- Zset

  排序场景，比如排行榜、粉丝列表、关注列表

### 底层实现

1. string的底层结构是**SDS（简单动态字符串）**

   相比于C语言原生字符串

   - SDS不仅可以保存文本，还可以保存二进制数据，比如图片、视频、声音等
   - SDS获取字符串长度的时间复杂度是O(1)，因为SDS结构里有len属性去记录字符串长度
   - SDS在拼接字符串时会检查SDS空间是否满足要求，如果不够会自动扩容，所以拼接字符串不会造成缓冲区溢出问题

2. List类型的底层数据结构是**压缩列表或双向链表**

   - 当元素个数小于512个，所有值小于64字节的话，Redis使用压缩链表作为List的底层结构
   - 如果不满足以上条件，会使用双向链表作为List的底层结构

   **但在Redis3.2版本之后，List数据类型的底层结构就只由quicklist实现了，替代了双向链表和压缩链表**

   ```
   quicklist本质上就是对ziplist的封装，本质上是一个双向链表，但链表的节点是quicklistnode。每个quicklistnode上存储的是ziplist
   ```

3. Hash类型由**压缩链表或哈希表**

   - 当元素个数小于512个，所有值小于64字节的话，Redis使用压缩链表作为List的底层结构
   - 如果不满足上面条件，Redis会使用哈希表作为hash类型的底层数据结构

   **但在Redis7.0版本之后，List数据类型的底层结构就只由listpack实现了，替代了双向链表和压缩链表**

4. Set底层是由**整数集合或哈希表**

   Set是一个有序但不允许重复的键值集合，它的存储顺序不会被按照插入的先后顺序进行存储

   - 当元素个数小于512个，所有值小于64字节的话，Redis使用整数集合作为Set的底层结构
   - 如果不满足上面条件，则Redis使用哈希表作为Set类型的底层数据结构

5. Zset底层数据结构是由**压缩列表或跳表**

   - 当元素个数小于512个，所有值小于64字节的话，Redis使用**压缩列表**
   - 如果不满足上面条件，则Redis使用跳表作为Set类型的底层数据结构

   **在 Redis 7.0 中，压缩列表数据结构已经废弃了，交由 listpack 数据结构来实现了。**

6.  
